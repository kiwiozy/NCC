# Safari PDF Preview Issue ‚Äì Complete Developer Guide

## Problem Summary
Safari fails to render embedded PDFs (blank page) in iframes inside modal dialogs. Chrome displays the PDF with native controls as expected. The issue occurs when using `blob:` or `data:` URLs to embed a PDF generated by Puppeteer.

---

## Root Cause

1. **WebKit limitation:** Safari (all modern versions) cannot reliably render PDFs from `blob:` or `data:` URLs inside `<iframe>` or `<embed>` elements. It will often show a blank page even though the same URL works in a new tab.
2. **Hidden iframe initialization bug:** If the iframe is loaded while the container (like a Mantine `<Modal>`) is hidden (`display:none`), Safari never initializes the internal PDF renderer. When the modal opens, the frame remains blank.
3. **Security and MIME issues:** Safari aggressively enforces `Content-Type` and CSP rules for embedded documents. Blob/data URLs bypass HTTP headers, so Safari can‚Äôt confirm proper MIME context.

---

## ‚úÖ Correct Implementation Pattern (Safari + Chrome Compatible)

### 1. Serve a Real URL Instead of Blob/Data
Have the backend return a **GET-accessible PDF URL**, not the binary bytes.

**Example:**
```ts
// POST /api/letters/pdf ‚Üí returns { id: 'abc123' }
// GET /api/letters/pdf/abc123 ‚Üí returns the PDF stream with headers:
// Content-Type: application/pdf
// Content-Disposition: inline; filename="letter.pdf"
```

Safari treats normal HTTP URLs as safe for its native viewer. Chrome will continue to work as usual.

### 2. Open Modal First, Then Load the PDF
Load the iframe *after* the modal becomes visible to avoid Safari‚Äôs hidden-rendering bug.

```tsx
const [modalOpen, setModalOpen] = useState(false);
const [pdfSrc, setPdfSrc] = useState<string | null>(null);

const handlePreviewPDF = async () => {
  setPdfLoading(true);

  const response = await fetch('/api/letters/pdf', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ html: combinedHTML }),
  });
  const { pdfId, pdfUrl } = await response.json();

  // Open modal first (ensures iframe will render in Safari)
  setModalOpen(true);

  // Delay setting src until next animation frame
  requestAnimationFrame(() => {
    setPdfSrc(pdfUrl ?? `/api/letters/pdf/${pdfId}`);
  });

  setPdfLoading(false);
};
```

### 3. Render the Iframe Conditionally

```tsx
<Modal opened={modalOpen} onClose={() => { setModalOpen(false); setPdfSrc(null); }} size="xl" title="Letter Preview">
  {pdfSrc ? (
    <iframe
      key={pdfSrc}
      src={pdfSrc}
      style={{ width: '100%', height: '80vh', border: 'none' }}
      title="PDF Preview"
    />
  ) : (
    <div style={{ height: '80vh' }}>Generating preview‚Ä¶</div>
  )}
</Modal>
```

This ensures Safari loads a visible iframe with a proper URL, fixing the blank-page issue.

---

## üß© Optional Fallbacks

### Tier 1 ‚Äì Native Viewer (Preferred)
- Real URL
- Iframe visible before load
- Inline `Content-Disposition`

### Tier 2 ‚Äì PDF.js Viewer (Always Works)
If you must support older Safari/iOS:
- Use [Mozilla PDF.js](https://mozilla.github.io/pdf.js/) or [`react-pdf`](https://github.com/wojtekmaj/react-pdf)
- Provides consistent viewer UI (zoom, page nav, download)

### Tier 3 ‚Äì Graceful Fallback
Detect load failure ‚Üí show download link:

```tsx
const [loadFailed, setLoadFailed] = useState(false);

const handleIframeLoad = () => {
  setTimeout(() => {
    const iframe = document.getElementById('pdf-frame') as HTMLIFrameElement;
    if (!iframe?.contentDocument?.body?.childElementCount) {
      setLoadFailed(true);
    }
  }, 1200);
};

{!loadFailed ? (
  <iframe id="pdf-frame" src={pdfSrc!} onLoad={handleIframeLoad} />
) : (
  <div>
    Safari couldn‚Äôt embed this PDF. <a href={pdfSrc!} target="_blank" rel="noreferrer">Open in new tab</a>
  </div>
)}
```

---

## üîç Why It Worked Before
Possible reasons older builds worked:
1. You previously used `URL.createObjectURL(blob)` instead of base64 ‚Äî slightly better Safari behavior.
2. Safari updates regressed embedded blob rendering.
3. Mantine Modal internals changed (modals now portal with `display:none`).
4. Your old route may have served a direct PDF URL instead of POST response.
5. Safari 18+ introduced tighter CORS checks on blob/data iframes.

---

## ‚úÖ Summary of Recommendations

| Area | Recommendation |
|------|----------------|
| PDF delivery | Return a GET-accessible URL (no blob/data) |
| Modal timing | Open modal *first*, then set iframe `src` |
| Fallback | Add detection for Safari + fallback link or PDF.js viewer |
| Headers | Ensure `Content-Type: application/pdf` and `Content-Disposition: inline` |
| UX | Keep a fallback "Download / Open in new tab" button |

---

## üß† Key Takeaways
- Safari cannot reliably render PDFs from `blob:` or `data:` URLs in hidden iframes.
- Always prefer serving a real URL and loading after modal visibility.
- For mission-critical UX, integrate PDF.js for a universal solution.

This fix ensures **native PDF previews work across Safari, Chrome, and other browsers**, while maintaining a clean Mantine modal UX.

